---
title: "HW3"
author: "Erik Andersen"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    keep_md: yes
  pdf_document:
    toc: true
  always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

```{r}
# Load packages
pacman::p_load(tidyverse, here)
```

### Question 1

```{r functions}
# In this chunk, were defining a bunch of convenience functions so the code is cleaner below

# True DGP: y_i = b0 + b1x_i + e_i
# Set n and sims
n = 10000
sims = 10000

# I'm learning functional programming, so this may not be the best way but I'm doing it anyways
# This function lets me generate functions that simulate x's with any variance for the error term
simulate = function(error_var){
    function(n){
      # x ~ N(10,4), eps ~ N(0,10)
      x_i = rnorm(n, 10, sqrt(4))
      error = rnorm(n, 0, sqrt(error_var))
      
      df = matrix(c(x_i, x_i + error), ncol = 2)
      colnames(df) = c("x", "x+u")
      return(df)
    }
}

# Generate our y variables from true date generating process
create_y = function(x, beta0 = 3, beta1 = 1){
  eps = rnorm(length(x), 0, sqrt(10))
  return(y = beta0 + beta1*x + eps)
}

# This function takes in a variance for measurement error and returns the coefficients of ols regressions of generated x's and y's
ols_coefs = function(measurement_error){
  # Generate regressors
  x = measurement_error(n)
  
  # Y needs to be generated with the actual values of x, not x with error
  y = create_y(x = x[,1])
  
  # Add constant to x
  x_mat = matrix(c(rep(1, nrow(x)), x[,2]), ncol = 2)
  
  # Run OLS
  coefs = solve(t(x_mat)%*%x_mat)%*%t(x_mat)%*%y
  names(coefs) = c("B0", "B1")
  return(coefs)
  
}
```

#### a)

```{r, dependson="functions"}
# X has no measurement error. Simulate betas a bunch of times
none_var = simulate(0) # zero mean for error means no measurment error

# Simulate ols
betas_none = sapply(1:sims, function(i) ols_coefs(none_var))

# Calculate mean and standard deviation of estimates
rowMeans(betas_none)
apply(betas_none, 1, sd)
```

#### c)

```{r, dependson="functions"}
# Now x has measurment error with standard deviation of 1
one_var = simulate(1)

# simulate ols
betas_one = sapply(1:sims, function(i) ols_coefs(one_var))

# Calculate mean and standard deviation of estimates
rowMeans(betas_one)
apply(betas_one, 1, sd)
```

#### d)

```{r, dependson="functions"}
# Now the measurement error has standard deviation 4
four_var = simulate(16)

betas_four = sapply(1:sims, function(i) ols_coefs(four_var))

# Calculate mean and standard deviation of estimates
rowMeans(betas_four)
apply(betas_four, 1, sd)
```

#### e) 

```{r iv, dependson="functions"}
# Manual two stage least squares. Reports coefficients from 1st and 2nd stage. This function is pretty slow, but I got tired of trying to make stuff fast on this homework
tsls = function(yvar, xvar, ivreg = FALSE){
  # Generate common x's
  x = rnorm(n, 10, sqrt(4))
  
  # Add two measurment errors. We're doing this without my fancy functions so the x's are common to both x's measured with error
  x_1 = x + rnorm(n, 0, sqrt(yvar)) 
  x_2 = x + rnorm(n, 0, sqrt(xvar)) 
  
  # Generate y
  y = create_y(x)
  
  # Regress x_2 on x_1
  reg1 = lm(x_1~x_2)
  
  # Save Coefficients and fitted values
  coefs1 = coef(reg1)
  fitted_values = fitted(reg1)
  
  # Run 2sls regression using fitted values
  reg2 = lm(y ~ fitted_values)
  coefs2 = coef(reg2)
  se = summary(reg2)$coefficients[2,2]
  
  # If we want the ivreg, run that
  if(ivreg == TRUE){
    reg3 = ivreg::ivreg(y~x_1 | x_2)
    # Return coefficients and standard errors
    coefs_iv = coef(reg3)
    se_iv = summary(reg3)$coefficients[2,2] }
  else{
    coefs_iv = NULL
    se_iv = NULL }
  

  
  # Make list of things to return
  return(list(coefs_first = coefs1,
       coefs_second = coefs2,
       se = se,
       coefs_iv = coefs_iv,
       se_iv = se_iv))
}
```

```{r meas1, dependson="iv"}
# Loop over this for x_1 ~ x_2
measurment_error1 = lapply(1:sims, function(i) tsls(1,16))
```

```{r, dependson="meas1"}
# Mean and variance of first stage coefficients
# First we have to extract the coefficients from the list object the function we created makes
delist = function(data, output){
  unlist = sapply(1:length(data), function(i) data[[i]][output])
  sapply(1:length(unlist), function(i) unlist[[i]])
}

coefs1 = delist(measurment_error1, 1)

# This created a matrix, so now we can get means and standard errors
rowMeans(coefs1)
apply(coefs1, 1, var)
```

#### f)

```{r, dependson="meas1"}
# Now report the mean and variance of 2sls estimator
coefs2 = delist(measurment_error1, 2)

rowMeans(coefs2)
apply(coefs2, 1, var)
```


#### g)

```{r meas2, dependson="iv"}
# Loop over generating function for x_2 ~ x_1
measurment_error2 = lapply(1:sims, function(i) tsls(16,1, ivreg = TRUE))
```

```{r, dependson="meas2"}
# Repeart e and f
coefs1 = delist(measurment_error2, 1)

rowMeans(coefs1)
apply(coefs1, 1, var)

coefs2 = delist(measurment_error2, 2)

rowMeans(coefs2)
apply(coefs2, 1, var)
```

#### h)

```{r, dependson="meas2"}
# Report mean of standard errors from each iteration of the loop
se = delist(measurment_error2,3)

mean(se)
```

#### i)

```{r, dependson="meas2"}
coefs_iv = delist(measurment_error2, 4)

rowMeans(coefs_iv)

# Calculate average se's from ivreg
se_iv = delist(measurment_error2, 5)
mean(se_iv)
```







































